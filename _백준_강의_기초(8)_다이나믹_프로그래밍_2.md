# 1149번: RGB거리
#### RGB거리에는 집이 N개 있다. 거리는 선분으로 나타낼 수 있고, 1번 집부터 N번 집이 순서대로 있다.
#### 집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다. 각각의 집을 빨강, 초록, 파랑으로 칠하는 비용이 주어졌을 때, 아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자.

#### 1. 1번 집의 색은 2번 집의 색과 같지 않아야 한다.
#### 2. N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.
#### 3. i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.


```python
## 1149번: RGB거리
#### RGB거리에는 집이 N개 있다. 거리는 선분으로 나타낼 수 있고, 1번 집부터 N번 집이 순서대로 있다.
#### 집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다. 각각의 집을 빨강, 초록, 파랑으로 칠하는 비용이 주어졌을 때, 아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자.

#### 1. 1번 집의 색은 2번 집의 색과 같지 않아야 한다.
#### 2. N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.
#### 3. i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.



# 정답

n = int(input())
a = [(0,0,0)] + [tuple(map(int,input().split())) for _ in range(n)]
d = [[0,0,0] for _ in range(n+1)]
for i in range(1, n+1):
    d[i][0] = min(d[i-1][1], d[i-1][2]) + a[i][0];
    d[i][1] = min(d[i-1][0], d[i-1][2]) + a[i][1];
    d[i][2] = min(d[i-1][0], d[i-1][1]) + a[i][2];
print(min(d[n][0], d[n][1], d[n][2]))
#print(d)
```

    3
    26 40 83
    49 60 57
    13 89 99
    96
    [[0, 0, 0], [26, 40, 83], [89, 86, 83], [96, 172, 185]]


# 15988번: 1, 2, 3 더하기 3
#### 정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오. (n은 양수이며 1,000,000보다 작거나 같다.)
#### 각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 1,000,000,009로 나눈 나머지를 출력한다.



```python
## 15988번: 1, 2, 3 더하기 3
#### 정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오. (n은 양수이며 1,000,000보다 작거나 같다.)
#### 각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 1,000,000,009로 나눈 나머지를 출력한다.

# 내가 풀은 답

mod = 1000000009

d = [0] * (1000000+1)

d[0] = 1
d[1] = 1
d[2] = 2


for i in range(3, 1000000+1):
    d[i] = d[i-3] + d[i-2] + d[i-1]
    d[i] %= mod





# 문제 입출력
t = int(input())

for _ in range(t):
    print(d[int(input()) % mod])
```

    3
    4
    7
    7
    44
    10
    274



```python
# 정답
d = [0]*1000001
mod = 1000000009
d[0] = 1
for i in range(1, 1000000+1):
    if i-1 >= 0:
        d[i] += d[i-1]
    if i-2 >= 0:
        d[i] += d[i-2]
    if i-3 >= 0:
        d[i] += d[i-3]
    d[i] %= mod

t = int(input())
for _ in range(t):
    n = int(input())
    print(d[n])
```

# 1309번: 동물원
#### 가로로 두칸 세로로 N칸인 사자 우리 2*N 배열에 사자를 배치하는 경우의 수가 몇 가지인지를 알아내는 프로그램을 작성해 주도록 하자.
#### 사자를 한 마리도 배치하지 않는 경우도 하나의 경우의 수로 친다고 가정한다. (1≤N≤100,000)



```python
## 1309번: 동물원
#### 가로로 두칸 세로로 N칸인 사자 우리 2*N 배열에 사자를 배치하는 경우의 수가 몇 가지인지를 알아내는 프로그램을 작성해 주도록 하자.
#### 사자를 한 마리도 배치하지 않는 경우도 하나의 경우의 수로 친다고 가정한다. (1≤N≤100,000)

# 내가 풀은 답

mod = 9901

d = [[0]*3 for _ in range(100000+1)]

d[1][0] = 1
d[1][1] = 1
d[1][2] = 1

for i in range(2, 100000+1):
    d[i][0] = (d[i-1][2] + d[i-1][1]) % mod

    d[i][1] = (d[i-1][0] + d[i-1][1] + d[i-1][2]) % mod

    d[i][2] = (d[i-1][0] + d[i-1][1]) % mod


print(sum(d[int(input())]) % mod)
```

    4
    41



```python
# 정답

n = int(input())
d = [[0]*3 for _ in range(n+1)]
d[0][0] = 1
for i in range(1, n+1):
    d[i][0] = d[i-1][0] + d[i-1][1] + d[i-1][2];
    d[i][1] = d[i-1][0] + d[i-1][2];
    d[i][2] = d[i-1][0] + d[i-1][1];
    for j in range(3):
        d[i][j] %= 9901
print(sum(d[n]) % 9901)
```

# 11057번: 오르막 수
#### 오르막 수는 수의 자리가 오름차순을 이루는 수를 말한다. 이때, 인접한 수가 같아도 오름차순으로 친다.
#### 수의 길이 N이 주어졌을 때, 오르막 수의 개수를 구하는 프로그램을 작성하시오. (수는 0으로 시작할 수 있다.) (1 ≤ N ≤ 1,000)



```python
## 11057번: 오르막 수
#### 오르막 수는 수의 자리가 오름차순을 이루는 수를 말한다. 이때, 인접한 수가 같아도 오름차순으로 친다.
#### 수의 길이 N이 주어졌을 때, 오르막 수의 개수를 구하는 프로그램을 작성하시오. (수는 0으로 시작할 수 있다.) (1 ≤ N ≤ 1,000)


# d[N][j] = d[N-1][j보다 작거나 같은 k]
# d[N][j] : 길이가 N인데 j를 마지막 수로 끝나는 '오르막 수'의 개수 (=모든 경우의 수)


# 내가 풀은 답

d = [[0]*10 for _ in range(1000+1)]
# 초기값 (수의 길이가 1일 때 -> 0~9 열 숫자 모두 1개)
for i in range(0, 10):
    d[1][i] = 1

mod = 10007
for i in range(2, 1000+1):
    for j in range(10):
        for k in range(0, j+1): # k의 범위는 0부터 j보다 작거나 같아야 함 !
            d[i][j] += d[i-1][k]

        d[i][j] %= mod


n = int(input())
print(sum(d[n]) % mod)
```

    2
    55


# 2156번: 포도주 시식
#### 효주는 포도주 시식을 하려고 하는데, 여기에는 다음과 같은 두 가지 규칙이 있다.
#### 1. 포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에 다시 놓아야 한다.
#### 2. 연속으로 놓여 있는 3잔을 모두 마실 수는 없다.
#### 효주는 될 수 있는 대로 많은 양의 포도주를 맛보기 위해서 어떤 포도주 잔을 선택해야 할지 고민하고 있다. 1부터 n까지의 번호가 붙어 있는 n개의 포도주 잔이 순서대로 테이블 위에 놓여 있고, 각 포도주 잔에 들어있는 포도주의 양이 주어졌을 때, 효주를 도와 가장 많은 양의 포도주를 마실 수 있도록 하는 프로그램을 작성하시오. 



```python
## 2156번: 포도주 시식
#### 효주는 포도주 시식을 하려고 하는데, 여기에는 다음과 같은 두 가지 규칙이 있다.
#### 1. 포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에 다시 놓아야 한다.
#### 2. 연속으로 놓여 있는 3잔을 모두 마실 수는 없다.
#### 효주는 될 수 있는 대로 많은 양의 포도주를 맛보기 위해서 어떤 포도주 잔을 선택해야 할지 고민하고 있다. 1부터 n까지의 번호가 붙어 있는 n개의 포도주 잔이 순서대로 테이블 위에 놓여 있고, 각 포도주 잔에 들어있는 포도주의 양이 주어졌을 때, 효주를 도와 가장 많은 양의 포도주를 마실 수 있도록 하는 프로그램을 작성하시오. 



# 1) 연속 개념 -> 2차원 다이나믹 이용한 풀이법

# 내가 풀은 답

n = int(input())

a = [0] # 편의를 위해 0번 포도주에 0 넣고 시작
for _ in range(n):
    a.append(int(input()))


d = [[0]*3 for _ in range(n+1)] # (1≤n≤10,000)
# 초기값
d[1][0] = 0
d[1][1] = a[1]
d[1][2] = a[1] # (주의 !)0 하면 오답 출력됨



for i in range(2, n+1):
    d[i][0] = max(d[i-1][0], d[i-1][1], d[i-1][2])

    d[i][1] = d[i-1][0] + a[i]

    d[i][2] = d[i-1][1] + a[i]



print(max(d[n]))

```

    6
    6
    10
    13
    9
    8
    1
    33



```python
print(d)
```

    [[0, 0, 0], [0, 6, 6], [6, 10, 16], [16, 19, 23], [23, 25, 28], [28, 31, 33], [33, 29, 32]]


- 1차원 다이나믹 이용한 풀이법


```python
# '이친수'문제 (0 or 1) 처럼 1."마심 O" or 2."마시지 X" 로 접근



n = int(input())

a = [0] # 편의를 위해 0번 포도주에 0 넣고 시작
for _ in range(n):
    a.append(int(input()))

## 다른 표현: a = [0] + [list(int(input()) for _ in range(n))]


d = [0] * (n+1)

# 초기값
d[1] = a[1]
## (주의) 1<=n 이므로 N이 1일수도 있음
if n >= 2:
    d[2] = a[1] + a[2]
#d[3] = max(a[1]+a[2], a[2]+a[3], a[1]+a[3])


for i in range(3, n+1):
    d[i] = max(d[i-1], d[i-2]+a[i], d[i-3]+a[i-1]+a[i]) # "포도주 마심 O" 이 경우1.0번 연속 or 경우2.1번 연속 or 경우3.3번 연속 세가지 경우 중 max 값을 가지는 이전 점화식 값 이어받기


print(d[n])
```

    6
    6
    10
    13
    9
    8
    1
    33



```python
print(d)
```

    [0, 6, 16, 23, 28, 33, 33]


# 1932번: 정수 삼각형
#### 맨 위층부터 시작해서 아래에 있는 수 중 하나를 선택하여 아래층으로 내려올 때, 이제까지 선택된 수의 합이 최대가 되는 경로를 구하는 프로그램을 작성하라. (대각선 왼쪽 또는 대각선 오른쪽에 있는 것 중에서만 선택할 수 있다.)
#### 삼각형의 크기는 1 이상 500 이하이다. 삼각형을 이루고 있는 각 수는 모두 정수이며, 범위는 0 이상 9999 이하이다.



```python
## 1932번: 정수 삼각형
#### 맨 위층부터 시작해서 아래에 있는 수 중 하나를 선택하여 아래층으로 내려올 때, 이제까지 선택된 수의 합이 최대가 되는 경로를 구하는 프로그램을 작성하라. (대각선 왼쪽 또는 대각선 오른쪽에 있는 것 중에서만 선택할 수 있다.)
#### 삼각형의 크기는 1 이상 500 이하이다. 삼각형을 이루고 있는 각 수는 모두 정수이며, 범위는 0 이상 9999 이하이다.



# D[i][j] : (i, j)에 도착했을 때, 합의 최대값
# D[i][j] = max(이전 왼쪽 대각선까지의 합, 이전 오른쪽 대각선까지의 합) + A[i][j]


# 내가 풀은 답

n = int(input())
a = [list(map(int, input().split())) for _ in range(n)]

d = [[0]*n for _ in range(n)]
d[0][0] = a[0][0]

for i in range(1, n):
    for j in range(i+1): # (주의) j의 범위: 0 ~ "i" 까지
        if j-1 >= 0: # j가 첫 번째 열일 때는, 이전 오른쪽 대각선만 존재
            d[i][j] = max(d[i-1][j-1], d[i-1][j]) + a[i][j]
        else:
            d[i][j] = d[i-1][j] + a[i][j]


print(max(d[n-1]))
```

    5
    7
    3 8
    8 1 0
    2 7 4 4
    4 5 2 6 5
    [[7, 0, 0, 0, 0], [10, 15, 0, 0, 0], [18, 16, 15, 0, 0], [20, 25, 20, 19, 0], [24, 30, 27, 26, 24]]



```python
print(a)
```

    [[7], [3, 8], [8, 1, 0], [2, 7, 4, 4], [4, 5, 2, 6, 5]]


# 11055번: 가장 큰 증가하는 부분 수열
#### 수열 A가 주어졌을 때, 그 수열의 증가 부분 수열 중에서 합이 가장 큰 것을 구하는 프로그램을 작성하시오. (최대길이 => 최대합 문제 버전)
#### 수열 A의 크기 N: (1 ≤ N ≤ 1,000) 수열 A를 이루고 있는 Ai: (1 ≤ Ai ≤ 1,000)



```python
## 11055번: 가장 큰 증가하는 부분 수열
#### 수열 A가 주어졌을 때, 그 수열의 증가 부분 수열 중에서 합이 가장 큰 것을 구하는 프로그램을 작성하시오. (최대길이 => 최대합 문제 버전)
#### 수열 A의 크기 N: (1 ≤ N ≤ 1,000) 수열 A를 이루고 있는 Ai: (1 ≤ Ai ≤ 1,000)


n = int(input())
a = list(map(int, input().split()))


d = [0] * n

d[0] = a[0] # 초기값 = 자기자신

for i in range(1, n):
    d[i] = a[i] # 초기값 = 자기자신

    for j in range(i): # (조건1) j < i
        if a[j] < a[i]: # (조건2) a[j] < a[i]
            # 최댓값 비교
            if d[i] < d[j] + a[i]:
                d[i] = d[j] + a[i] # 이전 점화식 값 이어받아 최대값 교체

    #print(d[i])


print(max(d)) 
```

    10
    1 100 2 50 60 3 5 6 7 8
    113


# 11722번: 가장 긴 감소하는 부분 수열
#### 수열 A가 주어졌을 때, 가장 긴 감소하는 부분 수열을 구하는 프로그램을 작성하시오.


```python
## 11722번: 가장 긴 감소하는 부분 수열
#### 수열 A가 주어졌을 때, 가장 긴 감소하는 부분 수열을 구하는 프로그램을 작성하시오.


## 방법 1) 입력으로 주어진 수열 A를 뒤집어서 가장 긴 증가하는 부분수열 구하기


# 내가 풀은 답
n = int(input())
a = list(map(int, input().split()))

a = a[::-1] ## 뒤집기

d = [0] * n

d[0] = 1

for i in range(1, n):
    d[i] = 1

    for j in range(i): # (조건1) j < i
        if a[j] < a[i]: # (조건2) a[j] < a[i]
            # 최댓값 비교
            if d[i] < d[j] + 1:
                d[i] = d[j] + 1 # 이전 점화식 값 이어받아 길이 1 증가

    #print(d[i])


print(max(d))  
```

    6
    10 30 10 20 20 10
    3



```python
## 방법 2) D[i] : A[i]로 끝나는 가장 긴 감소하는 부분수열의 최대 길이


# 내가 풀은 답
n = int(input())
a = list(map(int, input().split()))


d = [0] * n


for i in range(n):
    d[i] = 1

    for j in range(i): # (조건1) j < i
        if a[j] > a[i]: # (조건2) a[j] > a[i] ## 감소로 조건 변경
            # 최댓값 비교
            if d[i] < d[j] + 1:
                d[i] = d[j] + 1 # 이전 점화식 값 이어받아 길이 1 증가

    #print(d[i])


print(max(d))  
```

    6
    10 30 10 20 20 10
    3



```python
## 방법 3) D[i] = a[i]에서 "시작"하는 가장 긴 감소하는 부분 수열의 길이
## 앞 d배열에 의미가 있음 ->> 뒤 d배열에 의미가 있음

# 정답

n = int(input())
a = list(map(int,input().split()))

d = [0]*n

for i in range(n-1, -1, -1): ## 반복문을 뒤 인덱스부터 거꾸로 실행
    d[i] = 1
    for j in range(i+1, n): ## (1) j의 범위: i < j <= n-1
        if a[i] > a[j] and d[i] < d[j]+1: ## (2) 조건: "감소하는"
            d[i] = d[j]+1
print(max(d))
```

    6
    10 30 10 20 20 10
    3


# 11054번: 가장 긴 바이토닉 부분 수열
#### 수열 S가 어떤 수 Sk를 기준으로 S1 < S2 < ... Sk-1 < Sk > Sk+1 > ... SN-1 > SN을 만족한다면, 그 수열을 바이토닉 수열이라고 한다.
#### 수열 A가 주어졌을 때, 그 수열의 부분 수열 중 바이토닉 수열이면서 가장 긴 수열의 길이를 구하는 프로그램을 작성하시오.



```python
## 11054번: 가장 긴 바이토닉 부분 수열
#### 수열 S가 어떤 수 Sk를 기준으로 S1 < S2 < ... Sk-1 < Sk > Sk+1 > ... SN-1 > SN을 만족한다면, 그 수열을 바이토닉 수열이라고 한다.
#### 수열 A가 주어졌을 때, 그 수열의 부분 수열 중 바이토닉 수열이면서 가장 긴 수열의 길이를 구하는 프로그램을 작성하시오.


n = int(input())
a = list(map(int,input().split()))

d1 = [0]*n
d2 = [0]*n


# (1) 가장 긴 증가하는 부분 수열
for i in range(0, n):
    d1[i] = 1

    for j in range(i): # (조건1) j < i
        if a[j] < a[i]: # (조건2) a[j] < a[i]
            # 최댓값 비교
            if d1[i] < d1[j] + 1:
                d1[i] = d1[j] + 1 # 이전 점화식 값 이어받기   



# (2) 가장 긴 감소하는 부분 수열
for i in range(n-1, -1, -1): ## 반복문을 뒤 인덱스부터 거꾸로 실행
    d2[i] = 1
    for j in range(i+1, n): ## (1) j의 범위: i < j <= n-1
        if a[i] > a[j] and d2[i] < d2[j]+1: ## (2) 조건: "감소하는"
            d2[i] = d2[j]+1




# 답: "(가장 긴 증가하는 부분 수열)+(가장 긴 감소하는 부분 수열)-겹치는 1개" 의 최대값
d = [d1[i] + d2[i] - 1 for i in range(n)]

print(max(d))
```

    10
    1 5 2 1 4 3 4 5 2 1
    7


# 13398번: 연속합 2
#### n개의 정수로 이루어진 임의의 수열이 주어진다. 우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 단, 수는 한 개 이상 선택해야 한다.
#### 또, 수열에서 수를 하나 제거할 수 있다. (제거하지 않아도 된다)


```python
## 13398번: 연속합 2
#### n개의 정수로 이루어진 임의의 수열이 주어진다. 우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 단, 수는 한 개 이상 선택해야 한다.
#### 또, 수열에서 수를 하나 제거할 수 있다. (제거하지 않아도 된다)


# '가장 긴 바이토닉 부분 수열' 응용

n = int(input())
a = list(map(int,input().split()))

d1 = [0]*n
d2 = [0]*n


# (1) D1[i] : i번째 수에서 "끝나는" 최대 연속합
for i in range(0, n):
    d1[i] = a[i] ## 초기값: 자기자신

    if i == 0:
        continue 
    # i >= 1에 대해서만 실행
    d1[i] =  max(d1[i-1] + a[i], a[i]) # 1) 연속하는앞에 수에 현재 수 더한것 or 2) 현재 수부터 새로 연속 시작



# (2) D2[i] : i번째 수에서 "시작하는" 최대 연속합
for i in range(n-1, -1, -1): ## 반복문을 뒤 인덱스부터 거꾸로 실행
    d2[i] = a[i]

    if i == n-1:
        continue # d[N-1] = 그냥 A[i] 값이기 때문에

    d2[i] = max(d2[i+1]+a[i], a[i]) # 1) 연속하는 뒤의 수에 현재 수 더한것 or 2) 현재 수부터 새로 연속 시작




# 답: 삭제 안한 d에서의 최댓값, 삭제한 d1+d2에서의 최댓값 중 최댓값
ans = max(d1)

for i in range(1, n-1): ## 범위: 2 ~ n-1
    if ans < d1[i-1] + d2[i+1]:
        ans = d1[i-1] + d2[i+1] # 최대값 교체

print(ans)
```

    10
    10 -4 3 1 5 6 -35 12 21 -1
    54



```python
print(d1)
print(d2)
```

    [10, 6, 9, 10, 15, 21, -14, 12, 33, 32]
    [21, 11, 15, 12, 11, 6, -2, 33, 21, -1]


# 2133번: 타일 채우기
#### 3×N 크기의 벽을 2×1, 1×2 크기의 타일로 채우는 경우의 수를 구해보자. (1 ≤ N ≤ 30)


```python
## 2133번: 타일 채우기
#### 3×N 크기의 벽을 2×1, 1×2 크기의 타일로 채우는 경우의 수를 구해보자. (1 ≤ N ≤ 30)


# 규칙이 점화식을 띠는 경우
# D[i] = 3가지 * D[i-2칸] + (2가지 * D[i-4칸] + 2가지 * D[i-6칸] + 2가지 * D[i-8칸] + ...)

n = int(input())

d = [0]*(n+1)
d[0] = 1

for i in range(2, n+1, 2):
    d[i] = 3 * d[i-2]
    for j in range(i-4, -1, -2):
        d[i] += 2 * d[j]


print(d[n])
```

    2
    3

