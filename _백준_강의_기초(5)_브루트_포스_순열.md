# 10972번: 다음 순열
#### 첫째 줄에 입력으로 주어진 순열의 다음에 오는 순열을 출력한다. 만약, 사전순으로 마지막에 오는 순열인 경우에는 -1을 출력한다.



```python
## 10972번: 다음 순열
#### 첫째 줄에 입력으로 주어진 1부터 N까지의 수로 이루어진 순열의 다음에 오는 순열을 출력한다. (만약, 사전순으로 마지막에 오는 순열인 경우에는 -1을 출력한다.)


# 다음순열 (Next Permutation)
# 구현 알고리즘

def next_permutation(a):
    # 1) 뒤에서부터 시작해서 처음으로 내림차순(비오름차순)을 어기는 인덱스 찾기
    i = len(a)-1
    while i>0 and a[i-1] >= a[i]:
        i -= 1

    if i <= 0: ## 종료 조건(맨 첫 숫자까지 다 돌았는데 모두 '내림차순'인 경우 => 이미 '가장 마지막 순열')
        return False


    # 2) 기준점 뒤의 숫자들 중 가장 큰 수를 현재 i-1 번 숫자와 swap
    j = len(a)-1
    while a[i-1] >= a[j]:
        j -= 1

    a[i-1], a[j] = a[j], a[i-1]


    # 3) 현재 i부터 마지막까지 숫자 뒤집기
    j = len(a)-1
    while i < j:
        a[i], a[j] = a[j], a[i]
        i += 1
        j -= 1

    return True



n = int(input())
a = list(map(int, input().split()))

if next_permutation(a):
    print(' '.join(map(str, a)))
else:
    print(-1) # 입력으로 주어진 순열이 이미 가장 마지막 순열이라면
```

    4
    1 2 3 4
    1 2 4 3


# 10973번: 이전 순열
#### 1부터 N까지의 수로 이루어진 순열이 있다. 이때, 사전순으로 바로 이전에 오는 순열을 구하는 프로그램을 작성하시오. (만약, 사전순으로 가장 처음에 오는 순열인 경우에는 -1을 출력한다.)



```python
## 10973번: 이전 순열
#### 1부터 N까지의 수로 이루어진 순열이 있다. 이때, 사전순으로 바로 이전에 오는 순열을 구하는 프로그램을 작성하시오. (만약, 사전순으로 가장 처음에 오는 순열인 경우에는 -1을 출력한다.)


# 이전 순열 (Previous Permutation)
# 구현 알고리즘

def prev_permutation(a):
    # 1) 뒤에서부터 시작해서 처음으로 내림차순(비오름차순)을 어기는 인덱스 찾기
    i = len(a)-1
    while i>0 and a[i-1] <= a[i]:
        i -= 1

    if i <= 0: ## 종료 조건(맨 첫 숫자까지 다 돌았는데 모두 '내림차순'인 경우 => 이미 '가장 마지막 순열')
        return False


    # 2) 기준점 뒤의 숫자들 중 가장 큰 수를 현재 i-1 번 숫자와 swap
    j = len(a)-1
    while a[i-1] <= a[j]:
        j -= 1

    a[i-1], a[j] = a[j], a[i-1]


    # 3) 현재 i부터 마지막까지 숫자 뒤집기
    j = len(a)-1
    while i < j:
        a[i], a[j] = a[j], a[i]
        i += 1
        j -= 1

    return True



n = int(input())
a = list(map(int, input().split()))

if prev_permutation(a):
    print(' '.join(map(str, a)))
else:
    print(-1) # 입력으로 주어진 순열이 이미 가장 마지막 순열이라면
```

    4
    1 2 3 4
    -1


# 10974번: 모든 순열
#### N이 주어졌을 때, 1부터 N까지의 수로 이루어진 순열을 사전순으로 출력하는 프로그램을 작성하시오.



```python
## 10974번: 모든 순열
#### N이 주어졌을 때, 1부터 N까지의 수로 이루어진 순열을 사전순으로 출력하는 프로그램을 작성하시오.


def next_permutation(a):
    # 1) 뒤에서부터 시작해서 처음으로 내림차순(비오름차순)을 어기는 인덱스 찾기
    i = len(a)-1
    while i>0 and a[i-1] >= a[i]:
        i -= 1

    if i <= 0: ## 종료 조건(맨 첫 숫자까지 다 돌았는데 모두 '내림차순'인 경우 => 이미 '가장 마지막 순열')
        return False


    # 2) 기준점 뒤의 숫자들 중 가장 큰 수를 현재 i-1 번 숫자와 swap
    j = len(a)-1
    while a[i-1] >= a[j]:
        j -= 1

    a[i-1], a[j] = a[j], a[i-1]


    # 3) 현재 i부터 마지막까지 숫자 뒤집기
    j = len(a)-1
    while i < j:
        a[i], a[j] = a[j], a[i]
        i += 1
        j -= 1

    return True



n = int(input())
a = list(range(1, n+1))

# Do-While 문
while True:
    print(' '.join(map(str, a))) ##(1) 첫 순열(1 2 3) 출력
    if not next_permutation(a): ##(2) 다음 순열 함수를 통해 출력 False한 경우라면 (즉, 가장 "마지막 순열"에 도달)
        break # 함수 내에서 False한 경우라면 종료 !(즉, 가장 "마지막 순열"에 도달) -> break 빠져나와 문제해결 종료
```

    3
    1 2 3
    1 3 2
    2 1 3
    2 3 1
    3 1 2
    3 2 1



```python
n = 5
a = list(range(1, n+1))

print(a)
```

    [1, 2, 3, 4, 5]


# 10819번: 차이를 최대로
#### N개의 정수로 이루어진 배열 A가 주어진다. 이때, 배열에 들어있는 정수의 순서를 적절히 바꿔서 다음 식의 최댓값을 구하는 프로그램을 작성하시오. (3 ≤ N ≤ 8)
#### |A[0] - A[1]| + |A[1] - A[2]| + ... + |A[N-2] - A[N-1]|


```python
## 10819번: 차이를 최대로
#### N개의 정수로 이루어진 배열 A가 주어진다. 이때, 배열에 들어있는 정수의 순서를 적절히 바꿔서 다음 식의 최댓값을 구하는 프로그램을 작성하시오. (3 ≤ N ≤ 8)
#### |A[0] - A[1]| + |A[1] - A[2]| + ... + |A[N-2] - A[N-1]|


# 모든 경우의 수 : N! = 8! = 40320 -> 브루트포스 가능

# 순열 알고리즘
def next_permutation(a):
    # 1) 뒤에서부터 시작해서 처음으로 내림차순(비오름차순)을 어기는 인덱스 찾기
    i = len(a)-1
    while i>0 and a[i-1] >= a[i]:
        i -= 1

    if i <= 0: ## 종료 조건(맨 첫 숫자까지 다 돌았는데 모두 '내림차순'인 경우 => 이미 '가장 마지막 순열')
        return False


    # 2) 기준점 뒤의 숫자들 중 가장 큰 수를 현재 i-1 번 숫자와 swap
    j = len(a)-1
    while a[i-1] >= a[j]:
        j -= 1

    a[i-1], a[j] = a[j], a[i-1]


    # 3) 현재 i부터 마지막까지 숫자 뒤집기
    j = len(a)-1
    while i < j:
        a[i], a[j] = a[j], a[i]
        i += 1
        j -= 1

    return True





# 문제 수식대로 계산해주는 함수 (절댓값의 합)
def calc(a):
    sum = 0

    for i in range(1, len(a)):
        sum += abs(a[i-1] - a[i])

    return sum





# 문제 입출력
n = int(input())
a = list(map(int, input().split()))

a.sort() # "첫 순열"은 오름차순 정렬한 결과
ans = 0


while True:
    temp = calc(a)
    ans = max(ans, temp) # 최댓값 교체

    if not next_permutation(a): # "마지막 순열"에 도달해 False를 출력하면
        break # do-while문 끝


print(ans)
```

    6
    20 1 15 8 4 10
    62


# 10971번: 외판원 순회2
#### N과 비용 행렬이 주어졌을 때, 가장 적은 비용을 들이는 외판원의 순회 여행 경로를 구하는 프로그램을 작성하시오. (2 ≤ N ≤ 10)
#### 한 외판원이 어느 한 도시에서 출발해 N개의 도시를 모두 거쳐 다시 원래의 도시로 돌아오는 순회 여행 경로를 계획하려고 한다. 단, 한 번 갔던 도시로는 다시 갈 수 없다. (맨 마지막에 여행을 출발했던 도시로 돌아오는 것은 예외) 이런 여행 경로는 여러 가지가 있을 수 있는데, 가장 적은 비용을 들이는 여행 계획을 세우고자 한다.



```python
## 10971번: 외판원 순회2
#### N과 비용 행렬이 주어졌을 때, 가장 적은 비용을 들이는 외판원의 순회 여행 경로를 구하는 프로그램을 작성하시오. (2 ≤ N ≤ 10)
#### 한 외판원이 어느 한 도시에서 출발해 N개의 도시를 모두 거쳐 다시 원래의 도시로 돌아오는 순회 여행 경로를 계획하려고 한다. 단, 한 번 갔던 도시로는 다시 갈 수 없다. (맨 마지막에 여행을 출발했던 도시로 돌아오는 것은 예외) 이런 여행 경로는 여러 가지가 있을 수 있는데, 가장 적은 비용을 들이는 여행 계획을 세우고자 한다.


# 모든 경우의 수 : N! = 10! = 3,628,800 -> 브루트포스 가능
# 시간복잡도 : O(N * N!)

# 순열 알고리즘
def next_permutation(a):
    # 1) 뒤에서부터 시작해서 처음으로 내림차순(비오름차순)을 어기는 인덱스 찾기
    i = len(a)-1
    while i>0 and a[i-1] >= a[i]:
        i -= 1

    if i <= 0: ## 종료 조건(맨 첫 숫자까지 다 돌았는데 모두 '내림차순'인 경우 => 이미 '가장 마지막 순열')
        return False


    # 2) 기준점 뒤의 숫자들 중 가장 큰 수를 현재 i-1 번 숫자와 swap
    j = len(a)-1
    while a[i-1] >= a[j]:
        j -= 1

    a[i-1], a[j] = a[j], a[i-1]


    # 3) 현재 i부터 마지막까지 숫자 뒤집기
    j = len(a)-1
    while i < j:
        a[i], a[j] = a[j], a[i]
        i += 1
        j -= 1

    return True




# 문제 알고리즘
n = int(input())
w = [list(map(int, input().split())) for _ in range(n)]
d = list(range(n)) # 0 - N 까지 방문도시 인덱스로 활용할 배열 (순열)

ans = 2147483647

while True:
    ok = True
    sum = 0

    for i in range(0, n-1):
        if w[d[i]][d[i+1]] == 0: # 방문할 수 없다면
            ok = False # 종료 flag
            break # 및 조기종료

        else:
            sum += w[d[i]][d[i+1]]

    if ok == True and w[d[-1]][d[0]] != 0: # 지금까지 0~(n-1) 번 도시 방문 가능했고 && (n-1) 에서 0번 도시도 방문 가능할 때
        sum += w[d[-1]][d[0]]
        ans = min(ans, sum)

    # 종료 조건 (마지막 순열)
    if not next_permutation(d):
        break


print(ans)
```

    4
    0 10 15 20
    5 0 9 10
    6 13 0 12
    8 8 9 0
    35



```python
[range(5)]
```




    [range(0, 5)]




```python
list(range(5))
```




    [0, 1, 2, 3, 4]



- 시간 감소 구현 추가

- 1-2-3-4-5,

2-3-4-5-1,

3-4-5-1-2,

4-5-1-2-3,

4-1-2-3-4

는 모두 같은 경우로 취급됨을 이용



```python
# 시간 단축 방법
# 600ms -> 172ms


# 순열 알고리즘
def next_permutation(a):
    # 1) 뒤에서부터 시작해서 처음으로 내림차순(비오름차순)을 어기는 인덱스 찾기
    i = len(a)-1
    while i>0 and a[i-1] >= a[i]:
        i -= 1

    if i <= 0: ## 종료 조건(맨 첫 숫자까지 다 돌았는데 모두 '내림차순'인 경우 => 이미 '가장 마지막 순열')
        return False


    # 2) 기준점 뒤의 숫자들 중 가장 큰 수를 현재 i-1 번 숫자와 swap
    j = len(a)-1
    while a[i-1] >= a[j]:
        j -= 1

    a[i-1], a[j] = a[j], a[i-1]


    # 3) 현재 i부터 마지막까지 숫자 뒤집기
    j = len(a)-1
    while i < j:
        a[i], a[j] = a[j], a[i]
        i += 1
        j -= 1

    return True




# 문제 알고리즘
n = int(input())
w = [list(map(int, input().split())) for _ in range(n)]
d = list(range(n)) # 0 - N 까지 방문도시 인덱스로 활용할 배열 (순열)

ans = 2147483647

while True:

    ok = True
    sum = 0

    for i in range(0, n-1):
        if w[d[i]][d[i+1]] == 0: # 방문할 수 없다면
            ok = False # 종료 flag
            break # 및 조기종료

        else:
            sum += w[d[i]][d[i+1]]

    if ok == True and w[d[-1]][d[0]] != 0: # 지금까지 0~(n-1) 번 도시 방문 가능했고 && (n-1) 에서 0번 도시도 방문 가능할 때
        sum += w[d[-1]][d[0]]
        ans = min(ans, sum)

    # 종료 조건 (마지막 순열)
    if not next_permutation(d):
        break

    ## 방문 도시(순열)이 1로 시작하는 경우만 탐색
    ## 1번 도시가 아닌 경우 탐색을 종료함 !
    if d[0] != 0:
        break


print(ans)
```

    4
    0 10 15 20
    5 0 9 10
    6 13 0 12
    8 8 9 0
    35


# 6603번: 로또
#### 각 테스트 케이스는 한 줄로 이루어져 있다. 첫 번째 수는 k (6 < k < 13)이고, 다음 k개 수는 집합 S에 포함되는 수이다. S의 원소는 오름차순으로 주어진다.
#### 로또 번호로 선택할 6개 수를 고르는 모든 방법을 구하는 프로그램을 작성하시오.


```python
## 6603번: 로또
#### 각 테스트 케이스는 한 줄로 이루어져 있다. 첫 번째 수는 k (6 < k < 13)이고, 다음 k개 수는 집합 S에 포함되는 수이다. S의 원소는 오름차순으로 주어진다.
#### 로또 번호로 선택할 6개 수를 고르는 모든 방법을 구하는 프로그램을 작성하시오.


# 순열 알고리즘
def next_permutation(a):
    # 1) 뒤에서부터 시작해서 처음으로 내림차순(비오름차순)을 어기는 인덱스 찾기
    i = len(a)-1
    while i>0 and a[i-1] >= a[i]:
        i -= 1

    if i <= 0: ## 종료 조건(맨 첫 숫자까지 다 돌았는데 모두 '내림차순'인 경우 => 이미 '가장 마지막 순열')
        return False


    # 2) 기준점 뒤의 숫자들 중 가장 큰 수를 현재 i-1 번 숫자와 swap
    j = len(a)-1
    while a[i-1] >= a[j]:
        j -= 1

    a[i-1], a[j] = a[j], a[i-1]


    # 3) 현재 i부터 마지막까지 숫자 뒤집기
    j = len(a)-1
    while i < j:
        a[i], a[j] = a[j], a[i]
        i += 1
        j -= 1

    return True



while True:
    n, *a = list(map(int, input().split())) # ex) n: 7, a: [1, 2, 3, 4, 5, 6, 7]

    # 문제 종료 조건 (입력의 마지막 줄에는 0이 하나 주어진다.)
    if n == 0:
        break

    ######
    # 주어진 k개 중 6개만 선택 O(:1) & (k-6)개는 선택 X(:0)
    d = [0]*(n-6) + [1]*6
    ans = []

    while True:
        cur = [a[i] for i in range(n) if d[i]==1] # 순열에서 선택한 숫자만 담기
        ans.append(cur)

        if not next_permutation(d):
            break

    ans.sort() # 문제에서 '사전 순으로 출력한다.' 조건 만족
    for v in ans:
        print(' '.join(map(str, v)))
    ######


    print() # 문제에서 '각 테스트 케이스 사이에는 빈 줄을 하나 출력한다.' 조건 만족

```

    7 1 2 3 4 5 6 7
    1 2 3 4 5 6
    1 2 3 4 5 7
    1 2 3 4 6 7
    1 2 3 5 6 7
    1 2 4 5 6 7
    1 3 4 5 6 7
    2 3 4 5 6 7
    
    8 1 2 3 5 8 13 21 34
    1 2 3 5 8 13
    1 2 3 5 8 21
    1 2 3 5 8 34
    1 2 3 5 13 21
    1 2 3 5 13 34
    1 2 3 5 21 34
    1 2 3 8 13 21
    1 2 3 8 13 34
    1 2 3 8 21 34
    1 2 3 13 21 34
    1 2 5 8 13 21
    1 2 5 8 13 34
    1 2 5 8 21 34
    1 2 5 13 21 34
    1 2 8 13 21 34
    1 3 5 8 13 21
    1 3 5 8 13 34
    1 3 5 8 21 34
    1 3 5 13 21 34
    1 3 8 13 21 34
    1 5 8 13 21 34
    2 3 5 8 13 21
    2 3 5 8 13 34
    2 3 5 8 21 34
    2 3 5 13 21 34
    2 3 8 13 21 34
    2 5 8 13 21 34
    3 5 8 13 21 34
    
    0



```python
n, *a = list(map(int, "7 1 2 3 4 5 6 7".split()))
```


```python
n
```




    7




```python
a
```




    [1, 2, 3, 4, 5, 6, 7]


